<html>
    <head>
        <title>Game</title>
        <style>
            * {
                margin: 0;
            }
            body {
                background: #FCEBB6;
            }
            canvas {
                position: absolute;
                margin: auto;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
            }

        </style>
    </head>
    <body>
        <canvas id="c"></canvas>
        <script>
            var canvas = document.getElementById("c");
            canvas.addEventListener("mousedown", doMouseDown, false);
            var ctx = canvas.getContext("2d");

            var cellsNumber = 14;
            var size = window.innerHeight > window.innerWidth ? window.innerWidth : window.innerHeight;
            var step = size / cellsNumber;
            canvas.width = canvas.height = size;

            var borderWidth = 4;
            var wallWidth = 3;

            ctx.beginPath();
            for (var i = 0; i < size + step; i += step) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, size);

                ctx.moveTo(0, i);
                ctx.lineTo(size, i);
            }
            ctx.lineWidth = 0.3;
            ctx.stroke();

            var mainD = [];
            var sideD = [];
            for (var i = step / 2; i < size * 2; i += step) {
                mainD.push(createLine(0, i, i, 0));
                sideD.push(createLine(size - i, 0, size, i));
            }

            var walls = [];
            for (var i = 0; i < mainD.length; i++) {
                for (var j = 0; j < sideD.length; j++) {
                    if ((i === 6 && j >= 7 && j <= 20)
                    || (j === 6 && i >= 7 && i <= 20)
                    || (j === 21 && i >= 7 && i <= 20)
                    || (i === 21 && j >= 7 && j <= 20))
                        walls.push({m: i, s: j});
                }
            }

            ctx.beginPath();
            for (var i = 0; i < walls.length; i++)
                drawWall(walls[i].m, walls[i].s);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = borderWidth;
            ctx.stroke();

            var playerMove = 0;
            var points = [0, 0];
            var imgData = ctx.getImageData(0, 0, cellsNumber / 2 * step - step * 2, step * 2);

            ctx.font = step / 1.5 + 'px Verdana';
            function updateStats() {
                ctx.lineWidth = 1;
                ctx.putImageData(imgData, 0, 0);
                ctx.fillStyle = '#78C0A8';
                ctx.fillText("Blue: " + points[0], 5, step - step / 3);
                ctx.strokeStyle = '#121212';
                ctx.strokeText("Blue: " + points[0], 5, step - step / 3);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#F07818';
                ctx.fillText("Orange: " + points[1], 5, step / 2 + step);
                ctx.strokeText("Orange: " + points[1], 5, step / 2 + step);
                ctx.fill();
                ctx.stroke();

                ctx.lineWidth = 2;
                if (playerMove === 0) {
                    var lineY = step - step / 3 + 5;
                    ctx.moveTo(5, lineY);
                    ctx.lineTo(ctx.measureText("Blue: " + points[0]).width, lineY);
                } else {
                    var lineY = step / 2 + step + 5;
                    ctx.moveTo(5, lineY);
                    ctx.lineTo(ctx.measureText("Blue: " + points[0]).width, lineY);
                }
                ctx.stroke();
            }
            updateStats();

            function doMouseDown(event) {
                var x = event.pageX - canvas.offsetLeft;
                var y = event.pageY - canvas.offsetTop;

                var m = findNearestLineIndex(mainD, x, y);
                var s = findNearestLineIndex(sideD, x, y);

                if (!canMove(m, s))
                    return;

                console.log(m + " " + s);
                walls.push({m: m, s: s});

                if (playerMove === 0)
                    ctx.fillStyle = '#78C0A8';
                else
                    ctx.fillStyle = '#F07818';
                var pts = makeMove(m, s);
                points[playerMove] += pts;

                ctx.beginPath();
                drawWall(m, s);
                ctx.lineWidth = wallWidth;
                ctx.strokeStyle = '#000000';
                ctx.stroke();

                if (pts === 0) {
                if (playerMove === 0)
                    playerMove = 1;
                else
                    playerMove = 0;
                }
                updateStats();
            }

            function createLine(x0, y0, x1, y1) {
                var a = y0 - y1;
                var b = x1 - x0;
                var c = x0 * y1 - x1 * y0;
                var sqrt = Math.sqrt(a * a + b * b);
                return {x0, x1, y0, y1, a, b, c, sqrt};
            }

            function findNearestLineIndex(lines, x, y) {
                var minDest = size * size;
                var index;
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    d = Math.abs(line.a * x + line.b * y + line.c) / line.sqrt;
                    if (d < minDest) {
                        minDest = d;
                        index = i;
                    }
                }
                return index;
            }

            function getIntersectionPoint(l1, l2) {
                var det = function(a, b, c, d) {
                    return a * d - b * c;
                }
                var z = det(l1.a, l1.b, l2.a, l2.b);
                var x = -det(l1.c, l1.b, l2.c, l2.b) / z;
                var y = -det(l1.a, l1.c, l2.a, l2.c) / z;

                return {x, y};
            }

            function drawWall(m, s) {
                var horizontal = s % 2 !== m % 2;
                var p = getIntersectionPoint(mainD[m], sideD[s]);

                if (p.x <= 1)
                    p.x += borderWidth / 2;
                else if (p.x >= size - 1)
                    p.x -= borderWidth / 2;
                if (p.y <= 1)
                    p.y += borderWidth / 2;
                else if (p.y >= size - 1)
                    p.y -= borderWidth / 2;

                if (horizontal) {
                    ctx.moveTo(p.x - step / 2, p.y);
                    ctx.lineTo(p.x + step / 2, p.y);
                } else {
                    ctx.moveTo(p.x, p.y - step / 2);
                    ctx.lineTo(p.x, p.y + step / 2);
                }
            }

            function canMove(m, s) {
                if (m <= 6 || s <= 6 || m > 20 || s > 20)
                    return false;
                if (getWall(m, s) != null)
                    return false;
                return true;
            }

            function makeMove(m, s) {
                var e = function(wm, ws) { return getWall(wm, ws) != null; }
                var horizontal = s % 2 !== m % 2;

                var pts = 0;
                if (horizontal) {
                    if (e(m-1, s) && e(m-1, s-1) && e(m, s-1)) {
                        var p = getIntersectionPoint(mainD[m-1], sideD[s-1]);
                        ctx.fillRect(p.x - step / 2 + wallWidth / 2, p.y + wallWidth / 2, step - wallWidth, step - wallWidth);
                        pts++;
                    }
                    if (e(m, s+1) && e(m+1, s+1) && e(m+1, s)) {
                        var p = getIntersectionPoint(mainD[m], sideD[s]);
                        ctx.fillRect(p.x - step / 2 + wallWidth / 2, p.y + wallWidth / 2, step - wallWidth, step - wallWidth);
                        pts++;
                    }
                } else {
                    if (e(m, s+1) && e(m-1, s+1) && e(m-1, s)) {
                        var p = getIntersectionPoint(mainD[m-1], sideD[s+1]);
                        ctx.fillRect(p.x + wallWidth / 2, p.y- step / 2 + wallWidth / 2, step - wallWidth, step - wallWidth);
                        pts++;
                    }
                    if (e(m, s-1) && e(m+1, s-1) && e(m+1, s)) {
                        var p = getIntersectionPoint(mainD[m], sideD[s]);
                        ctx.fillRect(p.x + wallWidth / 2, p.y- step / 2 + wallWidth / 2, step - wallWidth, step - wallWidth);
                        pts++;
                    }
                }
                return pts;
            }

            function getWall(m, s) {
                var wall;
                for (var i = 0; i < walls.length; i++) {
                    wall = walls[i];
                    if (wall.m === m && wall.s === s)
                        return wall;
                }
                return null;
            }

        </script>
    </body>
</html>
